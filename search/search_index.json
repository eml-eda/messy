{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MESSY (Multi-layer Extra-functional Simulator in Systemc)","text":"<p>The availability of simulation platforms is a key ingredient for making RISC-V based hardware solutions pervasive. Simulators represent a cost-effective and scalable solution that enable rapid prototyping without the need for physical hardware. For these reasons, there is a growing availability of programs designed to simulate entire RISC-V chips. Some options include QEMU, Simulink, Renode, and GVSoC. However, these tools present some limitations. Most of them only simulate the computing core with scarce possibilities to perform system-level simulations. Moreover, they simulate only functional features, with poor support for extra-functional properties such as power consumption. This work tries to address these challenges by presenting a flexible simulator.</p> <p>MESSY is an open-source framework that integrates functional RISC-V simulation (achieved with GVSoC for the PULP cores) with SystemC-AMS (used to model extra-functional aspects, in detail power storage and distribution). The combination of GVSoC and SystemC-AMS in a single simulation framework allows to perform a DSE that is dependent on the mutual impact between functional and extra-functional aspects. </p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, please refer to the Getting Started</p>"},{"location":"codegen/","title":"Code Generation","text":"<p>The <code>messy.py</code> script uses a JSON configuration file to generate the SystemC/SystemC-AMS models for the simulation. This document explains the structure of the JSON file and the code generation process.</p>"},{"location":"codegen/#json-configuration-file","title":"JSON Configuration File","text":"<p>The JSON file defines the entire system to be simulated. Here is an example of a simple configuration:</p> <pre><code>{\n    \"resolution\": \"SC_MS\",\n    \"tracing\": {},\n    \"bus\": {\n        \"vref\": 3.3\n    },\n    \"core\": {\n        \"vref\": 1.8,\n        \"iss\": \"gvsoc\",\n        \"config\": {\n            \"path\": \"./gvsoc_config.json\",\n            \"axi_path\": \"/chip/axi_proxy\"\n        }\n    },\n    \"peripherals\": {\n        \"sensors\": {\n            \"mic_click\": {}\n        },\n        \"harvesters\": {\n            \"battery\": {},\n            \"photovoltaic\": {}\n        }\n    }\n}\n</code></pre>"},{"location":"codegen/#top-level-properties","title":"Top-Level Properties","text":"<ul> <li><code>resolution</code>: The simulation time resolution. See Resolution for more details.</li> <li><code>tracing</code>: Tracing configuration. See Tracing for more details.</li> <li><code>bus</code>: The power bus configuration. See Power Bus for more details.</li> <li><code>core</code>: The RISC-V core configuration. See Core for more details.</li> <li><code>peripherals</code>: The peripherals connected to the core, such as sensors and harvesters.</li> </ul>"},{"location":"codegen/#peripherals","title":"Peripherals","text":"<p>The <code>peripherals</code> object contains two sub-objects:</p> <ul> <li><code>sensors</code>: A list of sensors to be included in the simulation. See Sensors for more details.</li> <li><code>harvesters</code>: A list of harvesters to be included in the simulation. See Harvesters for more details.</li> </ul>"},{"location":"codegen/#code-generation-process","title":"Code Generation Process","text":"<p>The <code>messy.py</code> script reads the JSON configuration file and generates the SystemC/SystemC-AMS models based on the templates located in the <code>messy/codegen/templates</code> directory. The generated code is placed in the <code>messy/codegen/src</code> and <code>messy/codegen/include</code> directories.</p> <p>The generated code is then compiled and linked with the user application to create the final simulation executable.</p>"},{"location":"communication-example/","title":"SystemC Modules Timing","text":"<p>This file is intended for giving a full example of how the communication between the different modules works. It will mainly focus on the SystemC components. To have more details about the communication of GvSoC with SystemC, please refer to the timing documentation.</p> <p>The whole system works by means of requests, that can be of two types:</p> <ul> <li>Read: the core wants to read data from a sensor</li> <li>Write: the core wants to write data to a sensor</li> </ul> <p>When a request is made, the core need to set the corrected values to its output signals, to instruct the functional bus how to handle the request. The following code snippet shows how the core handles the request.</p> <p><pre><code>void Core::handle_req(MessyRequest *req)\n{\n    // ... other code\n    if (req-&gt;read_req)\n    {\n        // setting the correct signals to the functional bus for a read request\n    }\n    else\n    {\n        // // setting the correct signals to the functional bus for a write request\n    }\n    // ... other code\n}\n</code></pre> For all the details on the function <code>handle_req</code> please refer to the core.cpp file.</p> <p>The middle main component of the system is the functional bus. </p>"},{"location":"communication-example/#write-request","title":"Write Request","text":""},{"location":"communication-example/#core","title":"Core","text":"<p>When a write request is made, the core sets the following signals:</p> <ul> <li>request_address: is set to the address of the sensor memory that is being accessed</li> <li>request_data: is set to the pointer to the data that is being written to the sensor memory</li> <li>request_size: is set to the number of bytes that are being written to the sensor memory</li> <li>functional_bus_flag: is set to false, to indicate that the request is a write</li> <li>request_ready: is set to true, to indicate that the request is ready to be processed by the functional bus</li> </ul> <p>Then the core stops on a <code>wait()</code> statement, waiting for a change on the <code>request_go</code> signal. A visual representation of the sequence of events of this first part is shown in the following diagram.</p> <pre><code>sequenceDiagram\n    participant Core\n    participant Functional_bus\n\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n    Core-&gt;&gt;Functional_bus: request_address = address\n    Core-&gt;&gt;Functional_bus: request_data = data\n    Core-&gt;&gt;Functional_bus: request_size = size\n    Core-&gt;&gt;Functional_bus: functional_bus_flag = false\n    Core-&gt;&gt;Functional_bus: request_ready = true\n    Core-&gt;&gt;Core: wait(request_go)</code></pre>"},{"location":"communication-example/#functional-bus","title":"Functional Bus","text":"<p>The context is then passed to the functional bus, which is waiting on the hilighted <code>wait()</code> statement in the following code.</p> <pre><code>void Functional_bus::processing_data(){\n    // ..... other code\n    while (true){\n        if (request_ready.read() == true) {\n            // ... other code\n        }\n\n        // Wait for the next event\n        wait();\n\n        if(selected_sensor&gt;=0){\n            // ... other code\n        }\n\n    }\n}    \n</code></pre> <p>Since the <code>request_ready</code> signal, which was initially set to false, is now set to true, the functional bus wakes up and starts processing the request.  The first thing that the functional bus does is to set the <code>request_go</code> signal to 0, to indicate that the request is being processed. Then it continues by setting all the necessary signals to instruct the sensor how to handle the request. Specifically, it sets the following signals:</p> <ul> <li>address_out_sensor: is set to the address of the sensor memory that is being accessed</li> <li>data_out_sensor: is set to the pointer to the data that is being written to the sensor memory</li> <li>size_out_sensor: is set to the number of bytes that are being written to the sensor memory</li> <li>flag_out_sensor: is set to false, to indicate that the request is a write</li> <li>ready_sensor: is set to true, to indicate that the sensor can start processing the request</li> </ul> <p>After that, the functional bus stops again on the same <code>wait()</code> statement as before, waiting for the sensor to complete the request. </p> <pre><code>sequenceDiagram\n    participant Core\n    participant Functional_bus\n    participant Sensor\n\n    Sensor-&gt;&gt;Sensor: wait(ready_sensor)\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n    Core-&gt;&gt;Functional_bus: request_address = address\n    Core-&gt;&gt;Functional_bus: request_data = data\n    Core-&gt;&gt;Functional_bus: request_size = size\n    Core-&gt;&gt;Functional_bus: functional_bus_flag = false\n    Core-&gt;&gt;Functional_bus: request_ready = true\n    Core-&gt;&gt;Core: wait(request_go)\n\n    Note over Functional_bus: Functional bus wakes up\n    Functional_bus-&gt;&gt;Sensor: address_out_sensor = address\n    Functional_bus-&gt;&gt;Sensor: data_out_sensor = data\n    Functional_bus-&gt;&gt;Sensor: size_out_sensor = size\n    Functional_bus-&gt;&gt;Sensor: flag_out_sensor = false\n    Functional_bus-&gt;&gt;Sensor: ready_sensor = true\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)</code></pre>"},{"location":"communication-example/#sensor","title":"Sensor","text":"<p>The context, is then passed to the sensor, which wakes up and executes the write request. Inside the sensor, the size of the request is read and then the data is written to the sensor memory. Additionally the sensor requests a delay to the core to simulate the time it takes to write the data.</p> <p>The following code snippet shows how the sensor handles the request.</p> <pre><code>void Sensor_mic_click_functional::sensor_logic() {\n    while (true) {\n        if (enable.read() == true) {\n            if (ready.read() == true) {\n                // ... other code\n            } else {\n                // Write data to the register memory\n                for (unsigned int i = 0; i &lt; req_size_val; i++)\n                    register_memory[i + add] = req_core_val_addr[i];\n\n                // Request delay for the write operation\n                double start_time = sc_time_stamp().to_double(); ///&lt; Get the current simulation time\n                core-&gt;request_delay(start_time, 30, SIM_RESOLUTION); \n            }\n</code></pre> <p>When the sensor has completed the write request, it sets the <code>go</code> signal to true, to indicate that the request has been completed. Additionally, it also set the power consumption of the write state, that is used by the power instance of the sensor to calculate the power consumption. Finally, the sensor stops on a <code>wait()</code> statement, waiting for a change on the <code>ready</code> signal. </p> <p>This change in the <code>go</code> signal, which was previously set to false, wakes up the functional bus. </p> <pre><code>sequenceDiagram\n    participant Core\n    participant Functional_bus\n    participant Sensor\n\n    Sensor-&gt;&gt;Sensor: wait(ready_sensor)\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n    Core-&gt;&gt;Functional_bus: request_address = address\n    Core-&gt;&gt;Functional_bus: request_data = data\n    Core-&gt;&gt;Functional_bus: request_size = size\n    Core-&gt;&gt;Functional_bus: functional_bus_flag = false\n    Core-&gt;&gt;Functional_bus: request_ready = true\n    Core-&gt;&gt;Core: wait(request_go)\n\n    Note over Functional_bus: Functional bus wakes up\n    Functional_bus-&gt;&gt;Sensor: address_out_sensor = address\n    Functional_bus-&gt;&gt;Sensor: data_out_sensor = data\n    Functional_bus-&gt;&gt;Sensor: size_out_sensor = size\n    Functional_bus-&gt;&gt;Sensor: flag_out_sensor = false\n    Functional_bus-&gt;&gt;Sensor: ready_sensor = true \n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n\n    Note over Sensor: Sensor wakes up\n    Note over Sensor: Write data to the register memory\n    Note over Sensor: Request delay for the write operation\n    Sensor-&gt;&gt;Functional_bus: go = true\n    Sensor-&gt;&gt; Functional_bus: data_out = pointer to the data\n    Sensor-&gt;&gt;Sensor: wait(ready)    \n</code></pre>"},{"location":"communication-example/#functional-bus_1","title":"Functional Bus","text":"<p>The functional bus wakes up, sets the <code>request_go</code> signal to true, to indicate that the request has been completed. Additionally it sets the <code>ready_sensor</code> signal to false, to indicate that the sensor has completed the request and the <code>request_value</code> to the output of the sensors. Finally, the functional bus stops on a <code>wait()</code> statement, waiting for both the <code>request_go</code> and the <code>go_sensors</code> signals to become false. </p> <p>The following code snippet shows where the functional bus stops on the <code>wait()</code> statement.</p> <pre><code>void Functional_bus::processing_data(){\n    while (true){\n        // ... other code\n\n        if(selected_sensor&gt;=0){\n            // Check if a valid sensor was selected\n            response();\n\n            // Wait until the sensor and request are no longer ready\n            while (go_sensors[selected_sensor].read() != false &amp;&amp; request_ready.read() != false) {\n                wait();\n            }\n            // Indicate that the request processing is complete\n            request_go.write(false);\n        }\n    }\n}\n</code></pre> <pre><code>sequenceDiagram\n    participant Core\n    participant Functional_bus\n    participant Sensor\n\n    Sensor-&gt;&gt;Sensor: wait(ready_sensor)\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n    Core-&gt;&gt;Functional_bus: request_address = address\n    Core-&gt;&gt;Functional_bus: request_data = data\n    Core-&gt;&gt;Functional_bus: request_size = size\n    Core-&gt;&gt;Functional_bus: functional_bus_flag = false\n    Core-&gt;&gt;Functional_bus: request_ready = true\n    Core-&gt;&gt;Core: wait(request_go)\n\n    Note over Functional_bus: Functional bus wakes up\n    Functional_bus-&gt;&gt;Sensor: address_out_sensor = address\n    Functional_bus-&gt;&gt;Sensor: data_out_sensor = data\n    Functional_bus-&gt;&gt;Sensor: size_out_sensor = size\n    Functional_bus-&gt;&gt;Sensor: flag_out_sensor = false\n    Functional_bus-&gt;&gt;Sensor: ready_sensor = true \n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n\n    Note over Sensor: Sensor wakes up\n    Note over Sensor: Write data to the register memory\n    Note over Sensor: Request delay for the write operation\n    Sensor-&gt;&gt;Functional_bus: go = true\n    Sensor-&gt;&gt; Functional_bus: data_out = pointer to the data\n    Sensor-&gt;&gt;Sensor: wait(ready)    \n\n    Note over Functional_bus: Functional bus wakes up\n    Functional_bus-&gt;&gt;Core: request_go = true\n    Functional_bus-&gt;&gt;Core: request_value = data_out\n    Functional_bus-&gt;&gt;Sensor: ready_sensor = false\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready == false, go_sensors == false)\n</code></pre>"},{"location":"communication-example/#sensor-core","title":"Sensor &amp; Core","text":"<p>The context is then switched to the core and to the sensor. Thanks to a change on the <code>request_go</code> the core wakes up and sets the <code>request_ready</code> signal to false, to indicate that the request has been completed. The sensor, instead, is woke up by a change on the <code>ready</code> signal, and sets the <code>go</code> signal to false, to indicate that the request has been completed also on its side.</p> <pre><code>sequenceDiagram\n    participant Core\n    participant Functional_bus\n    participant Sensor\n\n    Sensor-&gt;&gt;Sensor: wait(ready_sensor)\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n    Core-&gt;&gt;Functional_bus: request_address = address\n    Core-&gt;&gt;Functional_bus: request_data = data\n    Core-&gt;&gt;Functional_bus: request_size = size\n    Core-&gt;&gt;Functional_bus: functional_bus_flag = false\n    Core-&gt;&gt;Functional_bus: request_ready = true\n    Core-&gt;&gt;Core: wait(request_go)\n\n    Note over Functional_bus: Functional bus wakes up\n    Functional_bus-&gt;&gt;Sensor: address_out_sensor = address\n    Functional_bus-&gt;&gt;Sensor: data_out_sensor = data\n    Functional_bus-&gt;&gt;Sensor: size_out_sensor = size\n    Functional_bus-&gt;&gt;Sensor: flag_out_sensor = false\n    Functional_bus-&gt;&gt;Sensor: ready_sensor = true \n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n\n    Note over Sensor: Sensor wakes up\n    Note over Sensor: Write data to the register memory\n    Note over Sensor: Request delay for the write operation\n    Sensor-&gt;&gt;Functional_bus: go = true\n    Sensor-&gt;&gt; Functional_bus: data_out = pointer to the data\n    Sensor-&gt;&gt;Sensor: wait(ready)    \n\n    Note over Functional_bus: Functional bus wakes up\n    Functional_bus-&gt;&gt;Core: request_go = true\n    Functional_bus-&gt;&gt;Core: request_value = data_out\n    Functional_bus-&gt;&gt;Sensor: ready_sensor = false\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready == false, go_sensors == false)\n\n    Note over Core: Core wakes up\n    Core-&gt;&gt;Functional_bus: request_ready = false\n    Core-&gt;&gt;Core: wait(request_go)\n    Note over Sensor: Sensor wakes up\n    Sensor-&gt;&gt;Functional_bus: go = false\n    Sensor-&gt;&gt;Sensor: wait(ready)</code></pre>"},{"location":"communication-example/#functional-bus-core","title":"Functional Bus &amp; Core","text":"<p>Finally, thanks to both the signal <code>request_ready</code> and <code>go_sensors</code> being false, the functional bus wakes up and sets the <code>request_go</code> signal to false, to indicate that the request is completed. The functional bus then stops on the <code>wait()</code> statement, waiting for the next request. On the other side, the core wakes up due to a change on the <code>request_go</code> signal, and exits the <code>handle_req</code> function. When a new re</p> <pre><code>sequenceDiagram\n    participant Core\n    participant Functional_bus\n    participant Sensor\n\n    Sensor-&gt;&gt;Sensor: wait(ready_sensor)\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n    Core-&gt;&gt;Functional_bus: request_address = address\n    Core-&gt;&gt;Functional_bus: request_data = data\n    Core-&gt;&gt;Functional_bus: request_size = size\n    Core-&gt;&gt;Functional_bus: functional_bus_flag = false\n    Core-&gt;&gt;Functional_bus: request_ready = true\n    Core-&gt;&gt;Core: wait(request_go)\n\n    Note over Functional_bus: Functional bus wakes up\n    Functional_bus-&gt;&gt;Sensor: address_out_sensor = address\n    Functional_bus-&gt;&gt;Sensor: data_out_sensor = data\n    Functional_bus-&gt;&gt;Sensor: size_out_sensor = size\n    Functional_bus-&gt;&gt;Sensor: flag_out_sensor = false\n    Functional_bus-&gt;&gt;Sensor: ready_sensor = true \n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n\n    Note over Sensor: Sensor wakes up\n    Note over Sensor: Write data to the register memory\n    Note over Sensor: Request delay for the write operation\n    Sensor-&gt;&gt;Functional_bus: go = true\n    Sensor-&gt;&gt; Functional_bus: data_out = pointer to the data\n    Sensor-&gt;&gt;Sensor: wait(ready)    \n\n    Note over Functional_bus: Functional bus wakes up\n    Functional_bus-&gt;&gt;Core: request_go = true\n    Functional_bus-&gt;&gt;Core: request_value = data_out\n    Functional_bus-&gt;&gt;Sensor: ready_sensor = false\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready == false, go_sensors == false)\n\n    Note over Core: Core wakes up\n    Core-&gt;&gt;Functional_bus: request_ready = false\n    Core-&gt;&gt;Core: wait(request_go)\n    Note over Sensor: Sensor wakes up\n    Sensor-&gt;&gt;Functional_bus: go = false\n    Sensor-&gt;&gt;Sensor: wait(ready)\n\n    Note over Functional_bus: Functional bus wakes up\n    Functional_bus-&gt;&gt;Core: request_go = false\n    Functional_bus-&gt;&gt;Functional_bus: wait(request_ready, go_sensors)\n    Note over Core: Core wakes up\n    Note over Core: Core exits handle_req</code></pre> <p>As you can see, the final situation of the system is the same as the initial one. The system is ready to handle a new request.</p>"},{"location":"communication-example/#read-request","title":"Read Request","text":""},{"location":"converters/","title":"Converters","text":"<p>Converters are essential components in electronic systems, and MESSY provides support for them through a lookup table (LUT) based approach. This allows for the modeling of various types of converters, such as Buck DC-DC converters.</p>"},{"location":"converters/#json-configuration","title":"JSON Configuration","text":"<p>A converter is defined within the JSON configuration file. Here is an example of a converter definition:</p> <pre><code>\"converter\": {\n    \"input_variable\": \"voltage\",\n    \"out_dir\": false,\n    \"lut\": {\n        \"input_values\": [0.6559, 0.7397, 0.8363, 0.9588, 1.0941, 1.1907, 1.4291, 1.7642, 1.8544, 1.9961, 2.4278, 2.5954, 2.6534, 2.7307, 2.7758, 2.7887, 2.9691, 3.1688, 3.3428, 3.5876, 3.7874, 3.9678, 4.1353, 4.3673, 4.5928, 4.7668, 4.9729],\n        \"efficiency_values\": [64.92, 69.37, 74.44, 78.79, 81.87, 83.69, 84.77, 85.86, 86.04, 85.95, 89.31, 90.66, 83.14, 75.71, 70.73, 68.46, 68.64, 68.19, 66.83, 63.93, 61.75, 59.31, 57.22, 54.77, 52.42, 50.51, 47.70]\n    }\n}\n</code></pre> <ul> <li><code>input_variable</code>: This parameter specifies whether the converter's efficiency is dependent on the input <code>\"voltage\"</code> or <code>\"current\"</code>.</li> <li><code>out_dir</code>: This boolean parameter determines the direction of the conversion. If <code>false</code>, the efficiency is calculated as <code>Pin / Pout</code>. If <code>true</code>, the efficiency is calculated as <code>Pout / Pin</code>.</li> <li><code>lut</code>: This object defines the lookup table for the converter's efficiency. It contains two arrays:<ul> <li><code>input_values</code>: The input voltage or current values.</li> <li><code>efficiency_values</code>: The corresponding efficiency values in percentage.</li> </ul> </li> </ul>"},{"location":"converters/#how-it-works","title":"How it works","text":"<p>The converter model uses the specified <code>input_variable</code> to look up the efficiency in the <code>lut</code>. The efficiency is then used to calculate the output power based on the <code>out_dir</code> parameter. This allows for the accurate modeling of power conversion losses in the system. </p>"},{"location":"core/","title":"Core","text":"<p>The core, alongside the adapter is probably the most important component of the whole system. Inside it contains all the necessary functions used to run the simulation. Inside it contains an instance of the <code>iss_adapter</code>.</p> <p>Similarly to most of the other components, the core is composed of two separate instances:</p> <ul> <li>Functional: this instance is responsible for defining the internal characteristics of the core. This instance interfaces with the core through a bus</li> <li>Power: this instance controls the state of the core and exposes its current and voltage</li> </ul>"},{"location":"core/#functional-instance","title":"Functional Instance","text":"<p>The functional instance is as follows:</p> <p></p>"},{"location":"core/#signals-summary","title":"Signals Summary","text":"<p>A summary of the signals is shown in the table below:</p> Signal Direction Connected to Description request_go input Functional Bus request_value input Functional Bus idx_sensor input Functional Bus request_address output Functional Bus request_data output Functional Bus request_size output Functional Bus functional_bus_flag output Functional Bus request_ready output Functional Bus power_signal output Core Power"},{"location":"core/#input-signals","title":"Input Signals","text":"<p>The input signals are:</p> <ul> <li>request_go: This signal is a boolean. It comes from the functional bus and is used to signal the core when a request is completed. Initially, request_go is set to 0, and it means that the request is being processed. When the request is completed, the functional bus sets the request go to 1. The core then wakes up and set the request_ready signal to 0. The functional bus then frees the sensor and sets the request_go to 0 again.</li> <li>request_value: This signal is a pointer. It comes from the sensor, then goes through the functional bus, and finally reaches the core. It contains the pointer to the data written to the sensor memory or read from it. When the request is a write this value is ignored</li> <li>idx_sensor: This signal is an integer value. It comes from the functional bus and contains the index of the sensor that is being accessed</li> </ul>"},{"location":"core/#output-signals","title":"Output Signals","text":"<p>The output signals are:</p> <ul> <li>request_address: This signal is an unsigned integer. It goes to the functional bus and contains the offset of the sensor memory that is being accessed. For example, if the sensor memory is contains 256 bytes and the request_address is set to 10 it means that we are accessing the 10th byte of the sensor memory. If the request has a size greater than 1, the request address will be the starting address of the memory block of the sensor.</li> <li>request_data: This signal is a pointer. It goes to the functional bus and contains the pointer to the data that is being written to the sensor memory. In case of a read request, this value is ignored and not set.</li> <li>request_size: this signal is an unsigned integer. It goes to the functional bus and contains the number of bytes that are being read from or written to the sensor memory. For example, if the request_size is set to 4 it means that we are reading or writing 4 elements of the sensor memory (since the sensor memory is byte-addressable).</li> <li>functional_bus_flag: This signal is a boolean. It goes to the functional bus and it used to indicate if the request is a read or a write. If the flag is set to true it means that the request is a read, otherwise it is a write.</li> <li>request_ready: This signal is a boolean. It goes to the functional bus and it is used to indicate that the request is ready to be processed by the functional bus. In the functional bus, in fact, the main loop is waiting for this signal to be set to true before forwarding the request to the sensor.</li> <li>power_signal: This signal is a double. It is not used and should be removed</li> </ul>"},{"location":"core/#power-instance","title":"Power Instance","text":"<p>TODO</p>"},{"location":"debugging/","title":"Debugging","text":"<p>This guide explains how to debug the code. The provided configuration needs Visual Studio Code. For other IDEs, you need to adapt the configuration. The whole configuration is provided in the <code>.vscode</code> folder. Everything should work out of the box. </p> <p>You have to create a docker container first. See Getting Started for more information.</p> <p>Important</p> <p>After that you need to install the Visual Studio Code <code>Remote - Containers</code> and <code>C/C++</code> extensions. You can find them here and here respectively. </p> <p>After that, you will find a docker icon in left bar. If you click it, it will show you the list of containers. You should see the container you created before. If you right click on it and select <code>Attach Visual Studio Code</code>, it will open a new window with the container attached.</p> <p>Important</p> <p>You have to install the <code>C/C++</code>  extension in the container too. You find the link here.</p> <p>Then you can open the folder <code>/messy</code> and click on the debug icon (green circle in the picture below) in the left bar. You should see a list of debug configurations. The one we are interested in is called <code>gdb</code> (red circle in the picture below). If you click on it, it will start the debugger. You can set breakpoints and step through the code.</p> <p></p>"},{"location":"docker/","title":"Docker","text":"<p>Note</p> <p>This is a more detailed explanation of the Dockerfile. For a quick start, please refer to the Getting Started guide.</p>"},{"location":"docker/#requirements","title":"Requirements","text":"<p>To build a Docker image, you need to have Docker installed on your machine. You can find the installation instructions here.</p>"},{"location":"docker/#overview-of-the-dockerfile","title":"Overview of the Dockerfile","text":"<p>Each Dockerfile is based on the Ubuntu 22.04 image. It installs the following dependencies:</p> <ul> <li>SystemC x.x.x (https://systemc.org/)</li> <li>Systemc-AMS x.x.x (https://www.accellera.org/downloads/standards/systemc)</li> <li>Core SDK</li> <li>Core RISC-V</li> <li>Make</li> <li>CMake</li> <li>g++</li> <li>python3</li> <li>python3-pip</li> </ul>"},{"location":"docker/#build-the-docker-image","title":"Build the Docker image","text":"<p>The first step is to build a Docker image. For example to build the <code>pulp-open</code> container the following command should be issued:</p> <pre><code>docker build . -f docker/pulp-open/Dockerfile -t messy --build-arg USER_ID=$(id -u ${USER}) --build-arg GROUP_ID=$(id -g ${USER})\n</code></pre> <p>The first time you run this command, it will take some time to build the image. Thanks to docker caching, the next time you run this command, it will be much faster.</p>"},{"location":"docker/#run-the-docker-container","title":"Run the Docker container","text":"<p>Once the image is built, you can run the container with the following command:</p> <pre><code>docker run -it --rm -v $(pwd):/messy messy:latest\n</code></pre> <p>This command will run the container and mount the current directory in the <code>/messy</code> directory of the container. This way, you can access the files from the container and the host. Now you should see the shell inside the container.</p>"},{"location":"flow/","title":"MESSY Flow","text":"<p>This document explains the workflow of MESSY, from system definition to simulation.</p> <pre><code>graph TD\n    A[JSON Configuration File] --&gt; B[GVSoC Application]\n    B --&gt; MESSY\n    subgraph MESSY\n        D[SystemC/AMS Model Generation] --&gt; E[Compilation]\n        E --&gt; F[Simulation]\n    end</code></pre>"},{"location":"flow/#1-system-definition-json","title":"1. System Definition (JSON)","text":"<p>The first step is to define the system using a JSON configuration file. This file describes the components of the system, such as the core, sensors, harvesters, functional bus, and power bus. While the components have a predefined structure, the JSON file allows you to customize their parameters, such as power consumption and delays.</p> <p>For more details on the JSON configuration, see the Codegen documentation.</p>"},{"location":"flow/#2-application-development","title":"2. Application Development","text":"<p>Next, you need to write the application that will run on the simulated RISC-V core. This application is written in C and defines the behavior of the system. You can find examples in the examples folder of the MESSY repository.</p>"},{"location":"flow/#3-running-the-messy-tool","title":"3. Running the MESSY Tool","text":"<p>The <code>messy.py</code> script is the main entry point for running the simulation. It takes two arguments:</p> <ul> <li><code>-f</code>: The path to the JSON configuration file.</li> <li><code>-a</code>: The path to the application directory.</li> </ul> <p>The script automates the following steps:</p>"},{"location":"flow/#a-systemcams-model-generation","title":"a. SystemC/AMS Model Generation","text":"<p>MESSY parses the JSON configuration file and generates the corresponding SystemC/SystemC-AMS models. The generated code is placed in the <code>messy/codegen/src</code> and <code>messy/codegen/include</code> directories.</p>"},{"location":"flow/#b-compilation","title":"b. Compilation","text":"<p>The script compiles both the user application and the generated SystemC/SystemC-AMS models. It uses <code>make</code> to build the application and the simulation environment.</p>"},{"location":"flow/#c-simulation","title":"c. Simulation","text":"<p>Finally, the script runs the simulation. The simulation is executed, and the results are saved to the output files specified in the configuration.</p>"},{"location":"functional-bus/","title":"Functional Bus","text":"<p>The functional bus is one of the most important component of the whole system. It is the \"man in the middle\" between the core and the sensors. It is responsible for managing the requests from the core and forwarding them to the sensors. It is also responsible for managing the responses from the sensors and forwarding them to the core.</p> <p>Differently from the other components, the functional bus does not have a dedicated power instance. The most similar thing to a power instance, is the power bus that is used to exchange the power state of all the components of the system and forward it to the harvesters.</p>"},{"location":"functional-bus/#functional-bus-instance","title":"Functional Bus Instance","text":"<p>The functional bus instance is as follows:</p> <p></p>"},{"location":"functional-bus/#signals-summary","title":"Signals Summary","text":"<p>A summary of the signals is shown in the table below:</p>"},{"location":"functional-bus/#input-signals","title":"Input Signals","text":"<p>The input signals are:</p> <ul> <li>request_address: This signal is an unsigned integer. It comes from the core and contains the offset of the sensor memory that is being accessed. For example, if the sensor memory is contains 256 bytes and the request_address is set to 10 it means that we are accessing the 10th byte of the sensor memory. If the request has a size greater than 1, the request address will be the starting address of the memory block of the sensor.  Inside the functional bus, this signal is subtracted by the base address of the sensor memory and then forwarded to the sensor through the <code>address_out</code> signal. This substraction is important because it allows to manage the situation where there are multiple sensors with different memory addresses.</li> <li>request_data: This signal is a pointer. It comes from the core and contains the pointer to the data that is being written to the sensor memory. </li> <li>flag_from_core: This signal is a boolean. It comes from the core and it used to indicate if the request is a read or a write. If the flag is set to true it means that the request is a read, otherwise it is a write. </li> <li>request_ready: This signal is a boolean. It comes from the core and it is used to indicate that the request is ready to be processed by the functional bus. In the functional bus, in fact, the main loop is waiting for this signal to be set to true before forwarding the request to the sensor. This signal is in the sensitivity list of the main thread of the functional bus.</li> <li>data_input_sensor[0:NUM_SENSORS]: This signal a pointer. It comes from the sensors and contains the pointer to the data that has been read or written from the sensor memory.</li> <li>go_sensor[0:NUM_SENSORS]: this signal is a boolean. It comes from the sensors and it is used to signal that the sensor has completed the operation. It is set to <code>true</code> when the sensor has finished, to <code>false</code> otherwise. It is very important because it is in the sensitivity list of the main thread of the functional bus. This means that when there is a change in the go_sensor signal, the functional bus is woken up. </li> <li>request_size: this signal is a unsigned integer. It comes from the core and contains the number of bytes that are being read from or written to the sensor memory. Inside the functional bus, this signal is forwarded to the sensors through the <code>size_out_sensor</code> signal.</li> </ul>"},{"location":"functional-bus/#output-signals","title":"Output Signals","text":"<p>The output signals are:</p> <ul> <li>request_value: This signal is a pointer. It goes to the core and contains the pointer to the data written to the sensor memory or read from it. When the request is a write this value is ignored.</li> <li>request_go: This signal is a boolean. It goes to the core. It is used to signal the core when a request is completed. Initially, request_go is set to 0, and it means that the request is being processed. When the request is completed, the functional bus sets the request go to 1. The core then wakes up and set the request_ready signal to 0. The functional bus then frees the sensor and sets the request_go to 0 again.</li> <li>idx_sensor: This signal is an integer. It goes to the core and contains the index of the sensor that is being accessed. This signal is used to manage the situation where there are multiple sensors with different memory addresses.</li> <li>address_out_sensor[0:NUM_SENSORS]: This signal is an unsigned integer. It goes to the sensors and contains the offset of the sensor memory that is being accessed. </li> <li>data_out_sensor[0:NUM_SENSORS]: This signal is a pointer. It goes to the sensors and contains the pointer to the data that is being written to the sensor memory. In case of a read request, this value can be ignored.</li> <li>size_out_sensor[0:NUM_SENSORS]: This signal is an unsigned integer. It goes to the sensors and contains the number of bytes that are being read from or written to the sensor memory.</li> <li>flag_out_sensor[0:NUM_SENSORS]: This signal is a boolean. It goes to the sensors and it used to indicate if the request is a read or a write. If the flag is set to true it means that the request is a read, otherwise it is a write.</li> <li>ready_sensor[0:NUM_SENSORS]: This signal is a boolean. It goes to the sensors  and it is used to indicate that the request is ready to be processed by the sensor. </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This document will guide you through the steps to get started with the project.</p>"},{"location":"getting-started/#clone-the-repository","title":"Clone the repository","text":"<p>First, clone the repository to your local machine:</p> <pre><code>git clone https://github.com/eml-eda/messy\ncd messy\n</code></pre>"},{"location":"getting-started/#dependencies","title":"Dependencies","text":"<p>To build the project, you need to have Docker installed on your machine. You can find the installation instructions here.</p>"},{"location":"getting-started/#build-the-docker-image","title":"Build the Docker image","text":"<p>The first step is to build a Docker image. For example to build the <code>pulp-open</code> container the following command should be issued:</p> <pre><code>docker build . -f docker/pulp-open/Dockerfile -t messy --build-arg USER_ID=$(id -u ${USER}) --build-arg GROUP_ID=$(id -g ${USER})\n</code></pre> <p>The first time you run this command, it will take some time to build the image. Thanks to docker caching, the next time you run this command, it will be much faster.</p>"},{"location":"getting-started/#run-the-docker-container","title":"Run the Docker container","text":"<p>Once the image is built, you can run the container with the following command:</p> <pre><code>docker run -it --rm -v $(pwd):/messy messy:latest\n</code></pre> <p>This command will run the container and mount the current directory in the <code>/messy</code> directory of the container. This way, you can access the files from the container and the host. Now you should see the shell inside the container.</p>"},{"location":"getting-started/#run-some-examples","title":"Run some examples","text":"<p>There are a few examples in <code>examples</code> folder. Try one of them:</p> <ul> <li>Hello World</li> <li>Periodic Sensor</li> </ul>"},{"location":"harvesters/","title":"Harvesters","text":"<p>Harvesters in MESSY are viewed in 2 different categories, batteries and sources. Batteries are more complex and contain by default AMS level simulation, while sources are defined in a simpler way.</p> <p>Currently the power scheduling tries to use all the power generated by the sources to contain the system load and eccesses are handled uniformly by the batteries.</p> <p>In the future, this aspect could be analyzed more and bring more control over power scheduling algorithms,</p>"},{"location":"harvesters/#batteries","title":"Batteries","text":"<p>The batteries are the most complex harvester in MESSY. The block representing a battery is the following:</p> <p></p> <p>Internally, it is modeled as a first-order RC circuit using the ELN (Electrical Linear Network) model available in SystemC-AMS.</p> <p></p>"},{"location":"harvesters/#signals-summary","title":"Signals Summary","text":"<p>A summary of the signals is shown in the table below:</p> Signal Direction Connected to Description i input Battery Converter Current v output Battery Converter Voltage soc output - State of Charge"},{"location":"harvesters/#input-signals","title":"Input Signals","text":"<p>The input signals are:</p> <ul> <li>i: This signal is a double.</li> </ul>"},{"location":"harvesters/#output-signals","title":"Output Signals","text":"<p>The output signals are:</p> <ul> <li>v: This signal is a double. It represents the voltage of the battery.</li> <li>soc: This signal is a double and represents the State of Charge of the battery. It is an output of the whole system, since it should be read from the top level module. </li> </ul>"},{"location":"harvesters/#definition-in-the-json-file","title":"Definition in the JSON file","text":"<p>A battery is defined through several parameters, following an example of a battery called <code>panasonic_batt</code>:</p> <pre><code>\"panasonic_batt\" : {\n    \"harvester_type\":\"battery\",\n    \"tracing\":{\n        ...\n    },\n    \"vref\":3.8,\n    \"soc_init\" : 100,\n    \"soc_end\" : 0,\n    \"capacity\":32,\n    \"self_discharge\":{\n        \"resolution\":{\n            \"unit\":\"SC_S\",\n            \"mult\":1\n        },\n        \"value\":0.001\n    },\n    \"converter\" : {\n        ...\n    }\n}\n</code></pre> <p>The firs parameter is the <code>harvester_type</code> one, this has to be set to battery, then tracing can be set as well.</p> <p>To continue a slate of battery related paramters are present, these are:</p> <ul> <li><code>vref</code>: reference voltage in Volts</li> <li><code>soc_init</code>: starting State of Charge of the battery</li> <li><code>soc_end</code>: battery State of Charge that should trigger the termination of the simulation</li> <li><code>capacity</code>: battery nominal capacity in mAh</li> <li><code>self_discharge</code>: object that represent the self dischargment of a battery, parametrized by a resolution object and a <code>value</code>, each resolution time the value will be discharged from the battery</li> <li><code>converter</code>: optionally MESSY allows harvesters to define a converter (better described in Converters)</li> </ul>"},{"location":"harvesters/#photovoltaic-panel","title":"Photovoltaic Panel","text":"<p>Another type of harvester supported by MESSY is the Photovoltaic cell. It's block is as follows:</p> <p></p>"},{"location":"harvesters/#signals-summary_1","title":"Signals Summary","text":"<p>A summary of the signals is shown in the table below:</p> Signal Direction Connected to Description i output Photovoltaic Converter Current v output Photovoltaic Converter Voltage"},{"location":"harvesters/#output-signals_1","title":"Output Signals","text":"<p>The output signals are:</p> <ul> <li>i: This signal is a double. It represents the current generated by the photovoltaic cell.</li> <li>v: This signal is a double. It represents the voltage of the photovoltaic cell.</li> </ul>"},{"location":"harvesters/#definition-in-the-json-file_1","title":"Definition in the JSON file","text":"<p>The sources are defined similarly, here is an example:</p> <pre><code>\"photovoltaic\" : {\n    \"harvester_type\" :\"source\",\n    \"vref\" :{\n        \"input_file\":\"input_files/gmonths.txt\",\n        \"lut\":{\n            \"input_values\":[250,500,750,1000],\n            \"voltage_values\":[2.9367,3.0710,3.1334,3.1689]\n        }\n    },\n    \"iref\":{\n        \"input_file\":\"input_files/gmonths.txt\",\n        \"lut\":{\n            \"input_values\":[250,500,750,1000],\n            \"current_values\":[13.4031,27.2251,41.8848,56.7245]\n        }\n    },\n    \"converter\" : {\n        ...\n    }\n}\n</code></pre> <p>The firs parameter is the <code>harvester_type</code> one, this has to be set to source, then tracing can be set as well as a converter.</p> <p>The specific parameters regards the enhanced input values such as <code>iref</code> and <code>vref</code>, these input values can be set statically, or to simulate more precisely natural conditions, they can be retrieved from an input file and generated by a LUT.</p>"},{"location":"how-to-build-docs/","title":"Usage","text":"<p>This document provides instructions on how to use the Messy toolchain for simulation and analysis, and how to build and serve the project documentation.</p>"},{"location":"how-to-build-docs/#running-simulations","title":"Running Simulations","text":"<p>The primary way to interact with the Messy toolchain is through the <code>messy.py</code> script, which orchestrates the <code>Makefile</code> targets.</p> <p>To build and run a simulation:</p> <pre><code>python3 messy/messy.py -f &lt;path_to_config_file&gt; -a &lt;path_to_application&gt;\n</code></pre> <ul> <li><code>&lt;path_to_config_file&gt;</code>: Path to a JSON configuration file (e.g., <code>messy/codegen/pulp_open.json</code>) or an IP-XACT XML file (e.g., <code>messy/codegen/ipxact/pulp_open_pv_panel/pulp_open_design.xml</code>). This file defines the system's components and their parameters.</li> <li><code>&lt;path_to_application&gt;</code>: Path to the embedded application source code (e.g., <code>examples/helloworld</code>).</li> </ul> <p>Example:</p> <pre><code>python3 messy/messy.py -f messy/codegen/pulp_open.json -a examples/helloworld\n</code></pre>"},{"location":"how-to-build-docs/#skipping-steps","title":"Skipping Steps","text":"<p>You can skip certain steps in the <code>messy.py</code> workflow using command-line flags:</p> <ul> <li><code>--skip_clean</code>: Skips the <code>make clean</code> step.</li> <li><code>--skip_codegen</code>: Skips the code generation (<code>make codegen</code> or <code>make codegen_ipxact</code>) and formatting steps.</li> <li><code>--skip_application</code>: Skips the application building (<code>make application</code>) step.</li> <li><code>--skip_docs</code>: Skips the documentation generation step.</li> </ul>"},{"location":"how-to-build-docs/#building-and-serving-documentation","title":"Building and Serving Documentation","text":"<p>To build and serve the project documentation locally, follow these steps:</p>"},{"location":"how-to-build-docs/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have Python 3 and <code>pip</code> installed.</p>"},{"location":"how-to-build-docs/#installation","title":"Installation","text":"<ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/eml-eda/messy\ncd messy\n</code></pre> </li> <li> <p>Create a virtual environment (recommended):</p> <pre><code>python3 -m venv doc_env\nsource doc_env/bin/activate\n</code></pre> </li> <li> <p>Install Python dependencies:</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> </ol>"},{"location":"how-to-build-docs/#building-and-serving","title":"Building and Serving","text":"<ol> <li> <p>Build the documentation:</p> <pre><code>make docs\n</code></pre> </li> <li> <p>Serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>This will typically serve the documentation at <code>http://127.0.0.1:8000/</code>. Open this URL in your web browser to view the documentation.</p> </li> </ol>"},{"location":"ipxact-parsing/","title":"IPXACT Parsing","text":"<p>For the purpose of working with ipxact designs instead of json designs a separate script has been created.</p> <p>It utilizes functions from the <code>messy/codegen/ipxact.py</code> module</p>"},{"location":"ipxact-parsing/#usage","title":"Usage","text":"<p>The script that will be used is called <code>messy/codegen/codegen_ipxact.py</code> and can be used like this:</p> <pre><code>python codegen_ipxact.py -f ipxact/pulp_open_pv_panel/pulp_open_design.xml\n</code></pre> <p>The -f flag specifies a path to the IPXACT top-level design file.</p>"},{"location":"ipxact-parsing/#structure","title":"Structure","text":"<p>The parsing script works as follows:</p> <ol> <li>At first the design file is read</li> <li>Then all the components are extracted from it (function read_ipxact_design(file_path))</li> <li>Then in for a cycle the resulting dictionary (of the same format as json) is assembled</li> <li>For each component it's XML representation is converted to JSON (function xml_to_json(element) and parse_element(element))</li> <li>And then it's format is adjusted to match the initial JSON format (functions process_bus(), process_core() etc.)</li> <li>For each component the version, library and vendor are checked (function sanity_check())</li> </ol> <p>Warning</p> <ul> <li>Component filenaming convention is component_name + \"_component.xml\"</li> <li>It is needed for the correct work of the script</li> </ul>"},{"location":"ipxact/","title":"IPXACT","text":"<p>This module will explain how the IPXACT design is constructed from a .json design.</p> <p>More about IPXACT can be read here</p> <p>This example is made for the following design - <code>messy/messy/codegen/pulp_open_pv_panel.json</code>:</p>"},{"location":"ipxact/#introduction","title":"Introduction","text":"<p>The IPXACT format assumes the presence of multiple files to describe one design. </p> <p>The main file is a design file <code>messy/codegen/ipxact/pulp_open_pv_panel/pulp_open_design.xml</code>, it describes all the components present and their interconnections.</p> <p>An example of a component instance:</p> <pre><code>&lt;ipxact:componentInstance&gt;\n    &lt;ipxact:instanceName&gt;pulp_open_core&lt;/ipxact:instanceName&gt;\n    &lt;ipxact:componentRef vendor=\"POLITO\" library=\"pulp_open\" name=\"core\" version=\"1.0\"/&gt;\n&lt;/ipxact:componentInstance&gt;\n</code></pre> <p>An example of connections:</p> <pre><code>&lt;ipxact:adHocConnection&gt;\n    &lt;ipxact:name&gt;core_I_to_core_converter_I_out&lt;/ipxact:name&gt;\n    &lt;ipxact:portReferences&gt;\n    &lt;ipxact:internalPortReference componentRef=\"core\" portRef=\"I\"/&gt;\n    &lt;ipxact:internalPortReference componentRef=\"core_converter\" portRef=\"I_out\"/&gt;\n    &lt;/ipxact:portReferences&gt;\n&lt;/ipxact:adHocConnection&gt;\n</code></pre> <p>The folder with the design has the required components which can be identified by their name, version, library and vendor. In the following parts we will describe different components and the decision which led to their final IPXACT form.</p>"},{"location":"ipxact/#component-parameters","title":"Component parameters","text":"<p>Component parameters usually can be either simple or have a complex tree structure, such as these aprameters of the pv module (converter will be discussed later):</p> <pre><code>    \"harvester_type\" :\"source\",\n    \"vref\" :{\n        \"input_file\":\"input_files/gmonths.txt\",\n        \"lut\":{\n            \"input_values\":[250,500,750,1000],\n            \"voltage_values\":[2.9367,3.0710,3.1334,3.1689]\n        }\n    },\n    \"iref\":{\n        \"input_file\":\"input_files/gmonths.txt\",\n        \"lut\":{\n            \"input_values\":[250,500,750,1000],\n            \"current_values\":[13.4031,27.2251,41.8848,56.7245]\n        }\n    },\n</code></pre> <p>Parameters like harvester_type will be put in the module parameters section and have a following description:</p> <pre><code>&lt;ipxact:moduleParameters&gt;\n    &lt;ipxact:moduleParameter parameterId=\"harvester_type\" resolve=\"user\" type=\"string\"&gt;\n        &lt;ipxact:name&gt;harvester_type&lt;/ipxact:name&gt;\n        &lt;ipxact:value&gt;source&lt;/ipxact:value&gt;\n    &lt;/ipxact:moduleParameter&gt;\n&lt;/ipxact:moduleParameters&gt;\n</code></pre> <p>Parameters like vref and iref for pv modules or states for sensors will be put in the VendorExtensions category of the IPXACT standard:</p> <pre><code>&lt;ipxact:vendorExtensions&gt;\n    &lt;vref&gt;\n        &lt;input_file&gt;input_files/gmonths.txt&lt;/input_file&gt;\n        &lt;lut&gt;\n            &lt;input_values&gt;[250,500,750,1000]&lt;/input_values&gt;\n            &lt;voltage_values&gt;[2.9367,3.0710,3.1334,3.1689]&lt;/voltage_values&gt;\n        &lt;/lut&gt;\n    &lt;/vref&gt;\n    &lt;iref&gt;\n        &lt;input_file&gt;input_files/gmonths.txt&lt;/input_file&gt;\n        &lt;lut&gt;\n            &lt;input_values&gt;[250,500,750,1000]&lt;/input_values&gt;\n            &lt;current_values&gt;[13.4031,27.2251,41.8848,56.7245]&lt;/current_values&gt;\n        &lt;/lut&gt;\n    &lt;/iref&gt;\n&lt;/ipxact:vendorExtensions&gt;\n</code></pre>"},{"location":"ipxact/#converters","title":"Converters","text":"<p>Since converters in the architectural diagram are presented as separate entities we decided to represent them as separate components.</p> <p>The ports each converter has correspond to the ports of the components it is connected to, such as this port of the pv_module:</p> <pre><code>&lt;ipxact:port&gt;\n    &lt;ipxact:name&gt;I&lt;/ipxact:name&gt;\n    &lt;ipxact:transactional&gt;\n        &lt;ipxact:initiative&gt;provides&lt;/ipxact:initiative&gt;\n        &lt;ipxact:transTypeDefs&gt;\n            &lt;ipxact:transTypeDef&gt;\n                &lt;ipxact:typeName&gt;double&lt;/ipxact:typeName&gt;\n                &lt;ipxact:viewRef&gt;interface&lt;/ipxact:viewRef&gt;\n            &lt;/ipxact:transTypeDef&gt;\n        &lt;/ipxact:transTypeDefs&gt;\n    &lt;/ipxact:transactional&gt;\n&lt;/ipxact:port&gt;\n</code></pre> <p>will be connected to the following port of the converter:</p> <pre><code>&lt;ipxact:port&gt;\n    &lt;ipxact:name&gt;I_in&lt;/ipxact:name&gt;\n    &lt;ipxact:transactional&gt;\n        &lt;ipxact:initiative&gt;requires&lt;/ipxact:initiative&gt;\n        &lt;ipxact:transTypeDefs&gt;\n            &lt;ipxact:transTypeDef&gt;\n                &lt;ipxact:typeName&gt;double&lt;/ipxact:typeName&gt;\n                &lt;ipxact:viewRef&gt;interface&lt;/ipxact:viewRef&gt;\n            &lt;/ipxact:transTypeDef&gt;\n        &lt;/ipxact:transTypeDefs&gt;\n    &lt;/ipxact:transactional&gt;\n&lt;/ipxact:port&gt;\n</code></pre> <p>And for each such input port a converter will have an output port. Type transactional for the port has been chosen because the end design is written in SystemC and TLM will represent it more accurately rather than a digital port of a certain bitwidth.</p>"},{"location":"ipxact/#bus","title":"Bus","text":"<p>The only part where this approach doesn't fully comply with the IPXACT standard is the bus description. Normally busses have their own ipxact format to fully express the protocol, but in this project the role of the bus is less complicated, it functions as a hub with many ports and it's description in the old .json file had only 1 parameter (vref). Taking this into account we made a decision to simply put the bus description in a separate component.</p> <p>Additionally, the following parameters of the system from the json file, which apply to the entire design:</p> <pre><code>{\n    \"resolution\":\"SC_MS\",\n\n    \"tracing\":{\n        \"messy_trace\":{\n            \"filename\":\"messy_trace.log\",\n            \"resolution\":{\n                \"unit\":\"SC_MS\",\n                \"mult\":1\n            }\n        }\n    },\n}\n</code></pre> <p>Will be stored as module parameters of the bus (or in it's vendor extensions for tracing)</p>"},{"location":"lut/","title":"Lookup Tables (LUTs)","text":"<p>Lookup Tables (LUTs) are used in MESSY to model the behavior of various components, such as converters and sensors. They provide a flexible way to define non-linear relationships between two variables.</p>"},{"location":"lut/#json-configuration","title":"JSON Configuration","text":"<p>A LUT is defined as a JSON object with two arrays: <code>input_values</code> and a second array that depends on the component being modeled.</p> <pre><code>\"lut\": {\n    \"input_values\": [0.6559, ...],\n    \"efficiency_values\": [64.92, ...]\n}\n</code></pre> <ul> <li><code>input_values</code>: An array of input values for the component.</li> <li><code>efficiency_values</code> / <code>voltage_values</code> / <code>current_values</code>: An array of corresponding output values. The name of this array depends on the component being modeled.</li> </ul>"},{"location":"lut/#how-it-works","title":"How it works","text":"<p>The LUT is implemented as a C++ class that performs linear interpolation to find the output value for a given input value. This allows for a more accurate representation of the component's behavior than a simple linear function.</p>"},{"location":"power-bus/","title":"Power Bus","text":"<p>The power bus is another key component of MESSY. It is the bus where all power components are connected to. Its structure is as follows:</p> <p></p>"},{"location":"power-bus/#signals-summary","title":"Signals Summary","text":"<p>A summary of the signals is shown in the table below:</p> Signal Direction Connected to Description core_current input Core Converter Current core_voltage input Core Converter Voltage voltage_sensor input Sensor Power Voltage of the Sensor sensor_current input Sensor Converter Current current_sources input Source Converter Current current_batteries output Battery Converter Current"},{"location":"power-bus/#input-signals","title":"Input Signals","text":"<p>The input signals are:</p> <ul> <li>core_current: This signal is a double. It comes from the Core converter and it indicates the current cosumed from the Core.</li> <li>core_voltage: This signal is a double. It comes from the Power instance of the core and it indicates the voltage of the core.</li> <li>voltage_sensor: This signal is an array of doubles. Its size is equal to the number of sensors. It comes from the each sensor power instance and it indicates the voltage of the corresponding sensor.</li> <li>sensor_current: This signal is an array of doubles. Its size is equal to the number of sensors. It comes from the each sensor converter and it indicates the current consumed by the corresponding sensor.</li> <li>current_sources: This signal is an array of double. Its size is equal to the number of sources. It comes from the each source converter and it indicates the current provided by the corresponding source.</li> </ul>"},{"location":"power-bus/#output-signals","title":"Output Signals","text":"<p>The output signals are:</p> <ul> <li>current_batteries: This signal is an array of double. Its size is equal to the number of batteries. It contains the sum of all the contributions of the currents consumed/produced by each sensor/source divided by the number of batteries. The code looks something like this:</li> </ul> <pre><code>void Power_bus::processing() {\n    double tmp_i;\n    total_current = 0;\n\n    for (int i = 0; i &lt; NUM_SENSORS; i++) {\n        tmp_i = current_sensors[i].read();\n        total_current += tmp_i; //(1)!\n    }\n\n    tmp_i = core_current.read();\n\n    total_current += tmp_i; //(2)!\n\n#if NUM_SOURCES &gt; 0\n    for (int i = 0; i &lt; NUM_SOURCES; i++) {\n        tmp_i = current_sources[i].read();\n        total_current -= tmp_i; //(3)!\n    }\n#endif\n\n#if NUM_BATTERIES &gt; 0\n    for (int i = 0; i &lt; NUM_BATTERIES; i++)\n        current_batteries[i].write(total_current / NUM_BATTERIES); //(4)!\n#endif\n}\n</code></pre> <ol> <li>Sum all the current contributions from the sensors</li> <li>Add the current from the core</li> <li>Subtract from the total current the current provided by each source</li> <li>Write the total current divided by the number of batteries to each battery converter</li> </ol>"},{"location":"power-bus/#definition-in-the-json-file","title":"Definition in the JSON file","text":""},{"location":"resolution/","title":"Resolution","text":"<p>A resolution object in MESSY is defined following SystemC timing units, a resolution is comprised of a unit measure (<code>SC_MS</code>, <code>SC_NS</code>, <code>SC_PS</code>) and a multiplier value, below an example that defines 30 seconds:</p> <pre><code>\"resolution\":{\n    \"unit\":\"SC_S\",\n    \"mult\":30\n}\n</code></pre>"},{"location":"sensors/","title":"Sensors","text":"<p>Sensors are crucial components in the MESSY framework, enabling the simulation of interactions between the virtual system and the physical world. Each sensor is comprised of two distinct instances:</p> <ul> <li>Functional Instance: This instance defines the internal characteristics and behavior of the sensor, interfacing with the core through a bus.</li> <li>Power Instance: This instance manages the sensor's power states, exposing its current and voltage to the power bus.</li> </ul>"},{"location":"sensors/#functional-instance","title":"Functional Instance","text":"<p>The functional instance is a SystemC module that models the sensor's behavior. It communicates with the Functional Bus to read and write data.</p> <p></p>"},{"location":"sensors/#signals-summary","title":"Signals Summary","text":"Signal Direction Connected to Description <code>enable</code> input - Enables or disables the sensor. <code>address</code> input Functional bus Address of the register to read from or write to. <code>data_in</code> input Functional bus Pointer to the input data for write operations. <code>req_size</code> input Functional bus Size of the data to be read or written. <code>flag_wr</code> input Functional bus A flag to determine the operation type: <code>true</code> for read, <code>false</code> for write. <code>ready</code> input Functional bus A flag indicating that the sensor is ready for a new operation. <code>data_out</code> output Functional bus Pointer to the output data for read operations. <code>go</code> output Functional bus A signal indicating the completion of an operation. <code>power_signal</code> output Power bus The current power state of the sensor."},{"location":"sensors/#input-signals","title":"Input Signals","text":"<p>The input signals are:</p> <ul> <li> <p>enable: this signal is used to enable the sensors. If the sensor is enable it will execute read or write operations and it will set the power state accordingly. Otherwise, the sensor is in a state that consumes 0 power.</p> <pre><code>if (enable.read() == true) {\n    // read or write operations\n} else {\n    power_signal.write(0); // (1)!\n}\n</code></pre> <ol> <li>If the sensor is disabled, it will consume 0 power.</li> </ol> </li> <li> <p>address: This signal is used to select the register of the sensor to read or write. For example, this is the code when reading:</p> <pre><code>unsigned int add = address.read(); // (1)!\n\ndata_out.write(register_memory + add); // (2)!\n</code></pre> <ol> <li>Read the address from the bus</li> <li>Write to the output bus the pointer of the memory of the sensor at address <code>add</code>.</li> </ol> </li> <li> <p>data_in: This signal represents the pointer to the input data. This is done in order to allow the possibility of passing multiple data to the sensor</p> </li> <li>req_size: This signal is used to define the size of the data that the sensor is going to read or write.</li> <li>flag_wr: This signal is used to define if the sensor is going to read or write. If the signal is true, the sensor is going to write, otherwise it is going to read.</li> <li>ready: This signal is used to define if the sensor is ready to read or write. </li> </ul>"},{"location":"sensors/#output-signals","title":"Output Signals","text":"<ul> <li>data_out: This signal represents the pointer to the output data. This signal goes to the functional bus</li> <li>go: This signal is used to signal that the sensor has completed the operation. It is set to <code>true</code> when the sensor has finished, to <code>false</code> otherwise. This signal goes to the functional bus</li> <li>power_signal: This signal represents the power state of the sensor. It is connected to the power instance of the sensor</li> </ul>"},{"location":"sensors/#power-instance","title":"Power Instance","text":"<p>The power instance is a SystemC-AMS module that models the power consumption of the sensor. It receives the power state from the functional instance and calculates the corresponding voltage and current consumption.</p> <p></p>"},{"location":"sensors/#signals-summary_1","title":"Signals Summary","text":"Signal Direction Connected to Description <code>func_signal</code> input Sensor Functional The power state of the sensor. <code>voltage_state</code> output Power bus &amp; Load Converter The voltage of the sensor. <code>current_state</code> output Power bus The current drawn by the sensor."},{"location":"sensors/#input-signals_1","title":"Input Signals","text":"<ul> <li><code>func_signal</code>: An integer representing the power state of the sensor, received from the functional instance.</li> </ul>"},{"location":"sensors/#output-signals_1","title":"Output Signals","text":"<ul> <li><code>voltage_state</code>: The voltage of the sensor.</li> <li><code>current_state</code>: The current drawn by the sensor.</li> </ul>"},{"location":"sensors/#json-configuration","title":"JSON Configuration","text":"<p>Sensors are defined in the <code>peripherals.sensors</code> section of the JSON configuration file. Here is an example of a microphone sensor:</p> <pre><code>\"mic_click\": {\n    \"vref\": 3.3,\n    \"register_memory\": 256,\n    \"states\": {\n        \"read\": {\n            \"current\": \"0.12\",\n            \"delay\": \"30\"\n        },\n        \"write\": {\n            \"current\": \"0.16\",\n            \"delay\": \"30\"\n        },\n        \"idle\": {\n            \"current\": \"0.002\"\n        }\n    }\n}\n</code></pre> <ul> <li><code>vref</code>: The reference voltage of the sensor in Volts.</li> <li><code>register_memory</code>: The size of the sensor's memory in bytes.</li> <li><code>states</code>: Defines the different power states of the sensor. Each state has a <code>current</code> consumption in mA and an optional <code>delay</code> in ms.</li> </ul>"},{"location":"sensors/#custom-sensors","title":"Custom Sensors","text":"<p>Currently, default sensors should only be used as placeholders in simple projects, since they do not implement any specific logic. For specialized behavior, you can implement custom sensors by setting <code>\"type\": \"custom\"</code>:</p> <pre><code>\"gesture\": {\n    \"type\": \"custom\",\n    \"custom_implementation\": {\n        \"path_header\": \"./gesture_sensor/gesture_sensor.hpp\",\n        \"path_source\": \"./gesture_sensor/gesture_sensor.cpp\"\n    },\n    \"vref\": 3.3,\n    \"register_memory\": 1024,\n    \"states\": { /* same as default sensors */ }\n}\n</code></pre> <p>Requirements: Custom sensors must maintain the exact same interface as default sensors (same ports, class name pattern, constructor). Only the <code>sensor_logic()</code> method implementation can be customized.</p> <p>Files: Place header and source files in the <code>templates/custom/</code> directory.</p>"},{"location":"sensors/#state-machine","title":"State Machine","text":"<p>The sensor's behavior is modeled as a state machine:</p> <pre><code>stateDiagram\n    [*] --&gt; Off\n    Off --&gt; Read\n    Off --&gt; Write\n    Read --&gt; Idle\n    Write --&gt; Idle\n    Idle --&gt; Read\n    Idle --&gt; Write</code></pre>"},{"location":"sensors/#memory-mapping","title":"Memory Mapping","text":"<p>Sensors are mapped to a specific memory region. The <code>baseaddress</code> of each sensor is automatically calculated by the <code>codegen.py</code> script based on the order of the sensors in the JSON file and the size of their <code>register_memory</code>.</p> <p>The <code>codegen.py</code> script calculates the base address for each sensor as follows:</p> <pre><code>for idx,(sensor_name,sensor) in enumerate(settings[\"peripherals\"][\"sensors\"].items()):\n    sensor[\"base\"] = baseaddress\n    sensor[\"ID\"] = idx\n    baseaddress += 1 + sensor[\"register_memory\"]\n</code></pre> <p>This loops over all the sensors in the JSON configuration file and assign the <code>baseaddress</code> to that sensor. For this reason, if we want one sensor before the other in the memory, is importan to define them correctly. The <code>baseaddress</code> is not to be confused with the <code>AXI_BASE</code>. In fact, GVSoC has some memory space that is fixed and cannot be touched, otherwise it causes segmantation faults. After that memory space, there is available memory space where the user can write whatever is needed.</p> <pre><code>...\n#define AXI_BASE 0x20000000\n...\nint main(void)\n{\n    ...\n\n    int* mic_click_sensor = (volatile int *)AXI_BASE+0x0;\n    ...\n}\n</code></pre> <p>As we can see in the code example (taken from the <code>periodic_sensors.c</code>), to define the address of the <code>mic_click_sensor</code> we just need to add <code>0x0</code> to the <code>AXI_BASE_ADDRESS</code>. This is because the used configuration for this example, which is the <code>pulp_open.json</code>, only contains one sensor. For more details on the example refer to the periodic sensor page.</p> <p>Supposing we have two sensors with a <code>register_memory</code> of 256 (0x100 in hexadecimal) and we want to access the memory of the second one, we should add to <code>AXI_BASE</code> the offset (which is 256, 0x100 in hexadecimal) with the respect to the starting address. </p> Name Base Address Memory Register Size Offset w.r.t AXI_BASE AXI_BASE 0x20000000 - 0 sensor1 0x20000000 0x100 0 sensor2 0x20000100 0x100 0x100"},{"location":"timing/","title":"Timing and Communication","text":"<p>This file is intended to describe how the timing between SystemC and GvSoC works. This is very important to understand, since it allows to grasp all the details about the communication between the two worlds. Everything mainly happens in the <code>core.cpp</code> and in the respective adapter (in this case <code>adapter_gvsoc.cpp</code>). The whole communication process is made possible thanks to some API that the chosen ISS (i.e GvSoC) exposes. Particularly the <code>step_until()</code> function is what actually advances the simulation inside GvSoc. This function executes the SoC functionality and returns the timestamp of the following event in the GVSoC queue. </p> <p>This function, has been wrapped in the <code>adapter_gvsoc.cpp</code> into a function called <code>exec_events_at(timestamp)</code>, which simply calls the <code>step_until()</code> function and returns the timestamp of the following event of the SoC. This is the function:</p> <pre><code>int64_t AdapterGvsoc::exec_events_at(int64_t timestamp){\n    return gvsoc-&gt;step_until(timestamp);\n}\n</code></pre> <p>In the case you want to add a new ISS, you should implement the <code>exec_events_at(timestamp)</code> function in the respective adapter. This function should call a functionally equivalent method of the ISS you are using.</p> <p>The simulation advances in the following way:</p> <ol> <li>Given the current SystemC timestamp, the <code>exec_events_at(timestamp)</code> function is called. This function advances the simulation in the ISS until the timestamp given as argument and returns the timestamp of the following event, that is called <code>next_timestamp</code>.</li> <li>The <code>next_timestamp</code> is then used to advance the SystemC simulation until that timestamp. This is done by calling the <code>wait()</code> function of the SystemC kernel. </li> <li>This process is repeated until the simulation ends.</li> </ol> <p>A view of the sequence diagram of the timing between SystemC and GvSoC is shown below:</p> <pre><code>sequenceDiagram\n    participant SystemC\n    participant Adapter\n    participant ISS\n    SystemC-&gt;&gt;Adapter: exec_events_at(timestamp)\n    Adapter-&gt;&gt;ISS: step_until(timestamp)\n    ISS--&gt;&gt;Adapter: next_timestamp\n    Adapter-&gt;&gt;SystemC: wait(next_timestamp)</code></pre>"},{"location":"tracing/","title":"Traces","text":"<p>The system supports several traces, these can be defined in the initial part of the configuration and used by sensors, converters, core and harvesters later on.</p> <p>The initial configuration can be done as follows:</p> <pre><code>\"tracing\":{\n    \"messy_trace\":{\n        \"filename\":\"messy_trace.log\",\n        \"resolution\":{\n            \"unit\":\"SC_MS\",\n            \"mult\":1\n        }\n    }\n}\n</code></pre> <p>Here a trace(multiple can be set) of name <code>messy_trace</code> is defined, the <code>filename</code> parameters define where the trace will be saved and finally the <code>resolution</code> describes the logging frequency through a resolution object better described in Resolution.</p> <p>To attach a trace to a sensor, harvester or what else during the configuration of that object the user shall set the <code>tracing</code> argument and describe for the related trace what to trace, for example below we want to trace the current of a sensor:</p> <pre><code>\"tracing\":{\n    \"messy_trace\":{\n        \"mic_click_I\":\"current\"\n    }\n}\n</code></pre> <p>Here the tracing is set only for a trace called <code>messy_trace</code> and for this trace only one parameter of the sensor is logged, this is the current and is saved as <code>mic_click_I</code> on the log.</p> <p>Currently voltages, current and State of Charge values can be traced quite easily.</p>"},{"location":"what-is-messy/","title":"What is MESSY?","text":"<p>MESSY (Multi-layer Extra-functional Simulator for SystemC) is an open-source framework that integrates functional RISC-V simulation with SystemC-AMS to enable detailed analysis of extra-functional properties like power consumption.</p>"},{"location":"what-is-messy/#key-features","title":"Key Features","text":"<ul> <li>Integrated Simulation: Combines functional simulation of RISC-V cores (using GVSoC) with SystemC-AMS for modeling extra-functional aspects.</li> <li>System-Level Power Modeling: Allows for detailed power modeling of the entire system, including the CPU, sensors, and other components.</li> <li>Modular and Configurable: Systems are defined using a JSON configuration file, allowing for easy customization and experimentation.</li> <li>Extensible: Users can add new components and models to the framework.</li> </ul>"},{"location":"what-is-messy/#how-it-works","title":"How it works","text":"<p>MESSY uses a JSON configuration file to define the system architecture, including the components and their connections. This file is then used to generate the SystemC code that simulates the system. The user can write C/C++ code to be executed by the RISC-V core, which can interact with the simulated hardware components.</p> <p>The simulation produces detailed output, including power consumption data, which can be used to analyze and optimize the system's energy efficiency.</p> <p></p>"},{"location":"what-is-messy/#getting-started","title":"Getting Started","text":"<p>To get started with MESSY, please refer to the Getting Started guide. </p>"},{"location":"examples/hello-world/","title":"Hello World","text":""},{"location":"examples/hello-world/#how-to-run-it","title":"How to run it","text":"<p>Before running this example, you have launch the docker container. You can find the instructions in the Docker page of the documentation.</p> <p>When you are in the docker container, you have to go to the <code>messy</code> directory:</p> <pre><code>cd /messy/messy/\n</code></pre> <p>Then we can run python:</p> <p><pre><code>python3 messy.py -f codegen/pulp_open.json -a /messy/examples/helloworld\n</code></pre> The parameters are:</p> <ol> <li><code>-f</code> is the file name of the chosen system configuration</li> <li><code>-a</code> is the path of the folder of the application</li> </ol>"},{"location":"examples/hello-world/#explanation","title":"Explanation","text":"<p>This code will build and execute the <code>helloworld</code> example. You should see the following output:</p> <pre><code>Entering main controller\n[31 0] Hello World!\nCluster master core entry\n[0 7] Hello World!\n[0 6] Hello World!\n[0 5] Hello World!\n[0 4] Hello World!\n[0 3] Hello World!\n[0 2] Hello World!\n[0 0] Hello World!\n[0 1] Hello World!\nCluster master core exit\nBye !\n</code></pre>"},{"location":"examples/periodic-sensor/","title":"Periodic Sensor","text":""},{"location":"examples/periodic-sensor/#how-to-run-it","title":"How to run it","text":"<p>Before running this example, you have launch the docker container. You can find the instructions in the Docker page of the documentation.</p> <p>When you are in the docker container, you have to go to the <code>messy</code> directory:</p> <pre><code>cd /messy/messy/\n</code></pre> <p>Then we can run python:</p> <p><pre><code>python3 messy.py -f codegen/pulp_open.json -a /messy/examples/periodic_sensors\n</code></pre> The parameters are:</p> <ol> <li><code>-f</code> is the file name of the chosen system configuration</li> <li><code>-a</code> is the path of the folder of the application</li> </ol>"},{"location":"examples/periodic-sensor/#explanation","title":"Explanation","text":"<p>This example, as the name suggest, is a simple example that periodically writes a value to the sensor memory. This example is useful to understand how to interact with the sensor memory and how the flow of a write operation works. For more information about the write request, please refer to the Communication Example page.</p> <p>By adding some print statements inside the functional model of the sensor, we can see how the memory of the sensor is updated, each time a write occurs.</p> <pre><code>[ITER 0/2880] 0.00 Hours Elapsed\n[SENSOR] Writing data to register memory at address 0\n[SENSOR] Data written: 2\n[ITER 1/2880] 0.01 Hours Elapsed\n[SENSOR] Writing data to register memory at address 0\n[SENSOR] Data written: 4\n[ITER 2/2880] 0.02 Hours Elapsed\n[SENSOR] Writing data to register memory at address 0\n[SENSOR] Data written: 6\n[ITER 3/2880] 0.02 Hours Elapsed\n[SENSOR] Writing data to register memory at address 0\n[SENSOR] Data written: 8\n[ITER 4/2880] 0.03 Hours Elapsed\n[SENSOR] Writing data to register memory at address 0\n[SENSOR] Data written: 10\n[ITER 5/2880] 0.04 Hours Elapsed\n[SENSOR] Writing data to register memory at address 0\n[SENSOR] Data written: 12\n[ITER 6/2880] 0.05 Hours Elapsed\n[SENSOR] Writing data to register memory at address 0\n[SENSOR] Data written: 14\n....\n</code></pre> <p>If we let this example run for enough time and inspect the <code>messy_trace.log</code> we can see the battery level decreasing over time. This is because the sensor is periodically writing to the memory, which in turn is consuming energy from the battery. This is a simple example to show how the sensor memory can be accessed and how the sensor can be used to interact with the system.</p>"},{"location":"examples/read-sensor/","title":"Read Sensor","text":""},{"location":"examples/read-sensor/#how-to-run-it","title":"How to run it","text":"<p>Before running this example, you have launch the docker container. You can find the instructions in the Docker page of the documentation.</p> <p>When you are in the docker container, you have to go to the <code>messy</code> directory:</p> <pre><code>cd /messy/messy/\n</code></pre> <p>Then we can run python:</p> <p><pre><code>python3 messy.py -f codegen/pulp_open.json -a /messy/examples/read_sensor\n</code></pre> The parameters are:</p> <ol> <li><code>-f</code> is the file name of the chosen system configuration</li> <li><code>-a</code> is the path of the folder of the application</li> </ol>"},{"location":"examples/read-sensor/#explanation","title":"Explanation","text":"<p>This example demonstrates how to read from a sensor's memory using different methods: direct byte access, <code>memcpy</code>, and accessing a custom struct. It initializes a memory region and then reads values from it, printing them to the console.</p> <p>You should see output similar to this:</p> <pre><code>...\nMessy uint8 sensor test, there should be 256 iters\n\n[uint8] 0 : 0\n[uint8] 1 : 1\n...\n[uint8] 255 : 255\n\n\nMessy memcpy sensor test, there should be 2 iters\n\n[memcpy]    0 : 0\n[memcpy]    128 : 128\n\n\nMessy examples with a struct, there should be 128 iters\n\n[struct]    0 : 0\n[struct]    1 : 2\n[struct]    2 : 4\n...\n[struct]    127 : 254\n</code></pre>"},{"location":"examples/read-write-multiple-sensors/","title":"Read Write Multiple Sensors","text":""},{"location":"examples/read-write-multiple-sensors/#how-to-run-it","title":"How to run it","text":"<p>Before running this example, you have launch the docker container. You can find the instructions in the Docker page of the documentation.</p> <p>When you are in the docker container, you have to go to the <code>messy</code> directory:</p> <pre><code>cd /messy/messy/\n</code></pre> <p>Then we can run python:</p> <p><pre><code>python3 messy.py -f codegen/pulp_open_double_sensor.json -a /messy/examples/read_write_multiple_sensors\n</code></pre> The parameters are:</p> <ol> <li><code>-f</code> is the file name of the chosen system configuration (note: this example uses <code>pulp_open_double_sensor.json</code> as it involves multiple sensors)</li> <li><code>-a</code> is the path of the folder of the application</li> </ol>"},{"location":"examples/read-write-multiple-sensors/#explanation","title":"Explanation","text":"<p>This example demonstrates reading from one sensor and writing to another, and then reading back from the second sensor. It highlights how to interact with multiple sensor instances within the simulation environment.</p> <p>You should see output similar to this:</p> <pre><code>...\nEntering main controller\n[0 0] Hello World!\nIter 0\nMicrophone sensor 0\nIter 1\nMicrophone sensor 0\n...\nIter 9\nMicrophone sensor 0\nIter_puppo 0\nMicrophone sensor 2 0\nIter_puppo 1\nMicrophone sensor 2 1\n...\nIter_puppo 9\nMicrophone sensor 2 9\n</code></pre>"},{"location":"examples/read-write-sensor/","title":"Read Write Sensor","text":""},{"location":"examples/read-write-sensor/#how-to-run-it","title":"How to run it","text":"<p>Before running this example, you have launch the docker container. You can find the instructions in the Docker page of the documentation.</p> <p>When you are in the docker container, you have to go to the <code>messy</code> directory:</p> <pre><code>cd /messy/messy/\n</code></pre> <p>Then we can run python:</p> <p><pre><code>python3 messy.py -f codegen/pulp_open.json -a /messy/examples/read_write_sensor\n</code></pre> The parameters are:</p> <ol> <li><code>-f</code> is the file name of the chosen system configuration</li> <li><code>-a</code> is the path of the folder of the application</li> </ol>"},{"location":"examples/read-write-sensor/#explanation","title":"Explanation","text":"<p>This example demonstrates a simple read-write operation to a single sensor's memory. It writes a sequence of values to the sensor and then reads them back, printing the results to the console.</p> <p>You should see output similar to this:</p> <pre><code>...\nMicrophone sensor 10\nMicrophone sensor 11\n</code></pre>"}]}